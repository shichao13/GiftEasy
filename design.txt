/*
 *  CS50 DESIGN DOCUMENT: How I Met Your... err... Implementation
 */

In this document we will be going over how we implemented a lot of the things that we did and the design reasoning behind it (as mentioned in the project spec...). At the back-end level, there were two main pieces of code, and three webpages. I'll first go over a high-level view of what we are doing in terms of webpages.

Our project has three main webpages. The first is a home page, where users are first introduced to the site and can enter in information as input for the rest of the project; this is led to the second page, where we display product results, and clicking on a product result allows users to go to a webpage where they can see nearby stores.

On the homepage, the most visible piece (other than the logo) is our search bar. This is a bar in which users are allowed to type up to three terms for the function to use as interests or hobbies. From a design perspective, we are asking for a lot of user input overall. So, it was necessary that we have some search bar that could succinctly allow the user to input everything that they needed, and the tag bar that we have created does exactly this. The tag bar allows users to see exact, definite inputs, including spaces. The autocomplete and the special tag features of the search bar are derived from the special javascript files located in a separate file. On the code level, it was initially very difficult to think of ways that we could implement this. In the end, we were able to find some help online for this input and the other, fancier ones. We won't bore you with a lot of the details of creating this form (it may be too late), especially since a lot of it revolves around the same issue: We need the user to give us lots of information, so how can we do this without making them fill out an extensive form?

The first major piece of code that we have is when dealing with the Amazon API, and one interesting choice of decisions is that the actual code, giftsuggestion.php, is a tenth of the length of the functions file that comes with it in order to make this page complete. Initially, everything was stuck inside giftsuggestion, but we made this decision after rewriting this code twice while our initial inputs were changing. Writing a functions page just made a lot more sense, since everything was split up and easy to rewrite.

In terms of what this code does, we split the user input into two, broad categories. The first is interests that the user inputs, needed mostly because we wanted to give a user free reign over what they are searching for a gift. The second is a personality type suggested by our site. This exists because we wanted consistent results, especially if our search function was not particularly helpful for the first kind of input. Each of these inputs follows a similar data flow. First, user data is processed and escaped with a function (a particularly long one, in fact) that makes sure that we aren't taking any sort of bad input. After this, the second type of data, which we will refer to as "Node Data", needs to have prebuilt gift ideas loaded into the function. Since we didn't have that much in terms of pre-thought of ideas, we just load the data into our webpage every time a user logs on. This is done through reading the file as a CSV. After this, we then use Amazon's API to return products for each of the search terms that we were given. Although this appears to be pretty simple, Amazon's API was pretty difficult to grasp, mainly because of the large number of randomly nested data structures and bad documentation. As a result, we have a lot of different functions that point to specific ways to query Amazon - of the ones we used, we have one for getting all the information, one for just getting department information (which is much faster), one for finding information given specific nodes, and a last one for finding multiple nodes at the same time. Amazon returns these inputs as XML files, which we then reduce into standard arrays for ease of use, then pass these arrays off into the results page.

We met some very major challenges when trying to create this back-end. APIs are not very flexible when we use them in novel ways, and Amazon in particular sometimes required us to query their server multiple times for a single item. For example, we first use a department to query for specific items in their department, but this actually does not allow for responses that give complete information about specific items. So, we then have to take this output and re-convert it into input to put into another query for specific items to display them. In addition, there are many other functions that we needed - there are some written about parsing down information, since Amazon tends to give us a lot of it, some about parsing text for specific words that we don't want, and others even about taking our specific type of data structure (awkwardly always named "$output") and submitting it to the $_SESSION superglobal. All and all, the functions file took the longest amount of hours to actually code and get together - we were unable to find functions that did what we wanted, so all but two of the functions were written by us. 

On our results page, we have the two arrays from before and a lot of CSS. The latter took quite a while, since this webpage is wholly about taking the mentioned two arrays that were delivered from the Amazon API and then displaying them on the page. We were considering either integrating the two types of input here, or keeping them separate, but finally decided on separation. This is for several reasons. The first is that it just is easier and more intuitive for the user if the stuff that they specifically inputted is on one side, and the rest is on the other. In addition, it made more sense from a programming perspective - because we queried Amazon in two different ways, the output vectors didn't really match in a lot of places. So, at first, we had to write separate functions for each kind of information, but eventually decided that we had to standardize the two and did so. The last reason that we did this is that a computer screen is too large for just one column, and our webpage aesthetically looks a lot better with the two columns here.

After clicking an item on the results page, the user is prompted to input a zip code. We select the term ‘category’ from the Amazon product, and convert the term from php into javascript because Google Maps only use javascript. The variables for the ‘term’ and ‘location’ are input into Yelp function. In Yelp, the term is hardcoded with ‘store’. It’s because without it, Yelp might give us places such as parks or stadiums, and our website’s aim is to lead the users to stores that sell products similar to the ones they clicked. We use JSON to convert the javascript strings into strings to output on the webpage. As to create the Google map, we used the Google map api with Yelp api. The website would initialize the map from the beginning at a default location of Harvard University. Then, at the website asks Yelp for information on the businesses related to the input term. We pull the business’ names, photo, and the photo url, and create markers around the location of the map. Depending on the user’s key term and location, the Yelp markers are automatically updated. 